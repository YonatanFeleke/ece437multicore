-- VHDL Entity multiCore_lib.mycpu.symbol
--
-- Created:
--          by - mg255.bin (cparch05.ecn.purdue.edu)
--          at - 17:07:59 12/07/11
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.2a (Build 7)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY mycpu IS
   PORT( 
      CLK      : IN     std_logic;
      nReset   : IN     std_logic;
      ramState : IN     std_logic_vector (1 DOWNTO 0);
      ramAddr  : OUT    std_logic_vector (15 DOWNTO 0);
      ramRen   : OUT    std_logic;
      ramWen   : OUT    std_logic;
      ramData  : OUT    std_logic_vector (31 DOWNTO 0);
      ramQ     : IN     std_logic_vector (31 DOWNTO 0);
      HALT     : OUT    std_logic
   );

-- Declarations

END mycpu ;

--
-- VHDL Architecture multiCore_lib.mycpu.struct
--
-- Created:
--          by - mg255.bin (cparch05.ecn.purdue.edu)
--          at - 17:08:00 12/07/11
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.2a (Build 7)
--
-- 
-- 
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY std;
USE std.textio.all;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.all;
USE ieee.std_logic_textio.all;

ARCHITECTURE struct OF mycpu IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL PC0           : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_MemWr1    : std_logic;
   SIGNAL PC1           : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_MEM2REG0  : std_logic;
   SIGNAL MEM_Out1      : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_Out0      : std_logic_vector(31 DOWNTO 0);
   SIGNAL MemRdData0    : std_logic_vector(31 DOWNTO 0);
   SIGNAL MemRdData1    : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_BusB0     : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_BusB1     : std_logic_vector(31 DOWNTO 0);
   SIGNAL WB_Halt1      : std_logic;
   SIGNAL iMemData0     : std_logic_vector(31 DOWNTO 0);
   SIGNAL iMemData1     : std_logic_vector(31 DOWNTO 0);
   SIGNAL MemWait0      : std_logic;
   SIGNAL aMemRead0     : std_logic;
   SIGNAL aMemWrite0    : std_logic;
   SIGNAL aMemWrData0   : std_logic_vector(31 DOWNTO 0);
   SIGNAL aMemRead1     : std_logic;
   SIGNAL aMemAddr1     : std_logic_vector(31 DOWNTO 0);
   SIGNAL aMemWrite1    : std_logic;
   SIGNAL aMemWrData1   : std_logic_vector(31 DOWNTO 0);
   SIGNAL iMemRead1     : std_logic;
   SIGNAL aiMemData1    : std_logic_vector(31 DOWNTO 0);
   SIGNAL cMemWait0     : std_logic;
   SIGNAL aMemRdData0   : std_logic_vector(31 DOWNTO 0);
   SIGNAL cMemWait1     : std_logic;
   SIGNAL aMemRdData1   : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_MemWr0    : std_logic;
   SIGNAL WB_Halt0      : std_logic;
   SIGNAL aMemAddr0     : std_logic_vector(31 DOWNTO 0);
   SIGNAL finalHalt0    : std_logic;
   SIGNAL finalHalt1    : std_logic;
   SIGNAL MEM_MEM2REG1  : std_logic;
   SIGNAL aiMemRead1    : std_logic;
   SIGNAL aiMemAddr1    : std_logic_vector(31 DOWNTO 0);
   SIGNAL aiMemRead0    : std_logic;
   SIGNAL aiMemAddr0    : std_logic_vector(31 DOWNTO 0);
   SIGNAL MemWait1      : std_logic;
   SIGNAL cpuwait0      : std_logic;
   SIGNAL cpuwait1      : std_logic;
   SIGNAL cMemAddr0     : std_logic_vector(31 DOWNTO 0);
   SIGNAL cMemSnoopEn0  : std_logic;
   SIGNAL cMemAddr1     : std_logic_vector(31 DOWNTO 0);
   SIGNAL cWait1        : std_logic;
   SIGNAL cWait0        : std_logic;
   SIGNAL aMemRead      : std_logic;
   SIGNAL aMemWrite     : std_logic;
   SIGNAL aMemAddr      : std_logic_vector(31 DOWNTO 0);
   SIGNAL aMemRdData    : std_logic_vector(31 DOWNTO 0);
   SIGNAL busy          : std_logic;
   SIGNAL arbWait0      : std_logic;
   SIGNAL arbWait1      : std_logic;
   SIGNAL aMemWait0     : std_logic;
   SIGNAL aMemWait1     : std_logic;
   SIGNAL ihit0         : std_logic;
   SIGNAL ihit1         : std_logic;
   SIGNAL iMemRead0     : std_logic;
   SIGNAL aiMemData0    : std_logic_vector(31 DOWNTO 0);
   SIGNAL cMemSnoopEn1  : std_logic;
   SIGNAL aMemWrData    : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_SC1       : std_logic;
   SIGNAL MEM_LL1       : std_logic;
   SIGNAL MEM_LL0       : std_logic;
   SIGNAL MEM_SC0       : std_logic;
   SIGNAL cRdX0         : std_logic;
   SIGNAL cRdX1         : std_logic;
   SIGNAL MEM_Rw1       : std_logic_vector(4 DOWNTO 0);
   SIGNAL MEM_Rw0       : std_logic_vector(4 DOWNTO 0);
   SIGNAL chrSnpWait0   : std_logic;
   SIGNAL chrSnpWait1   : std_logic;
   SIGNAL cacheSnoopEn1 : std_logic;
   SIGNAL cacheSnoopEn0 : std_logic;
   SIGNAL pid0          : std_logic;
   SIGNAL pid1          : std_logic;
   SIGNAL Freeze0       : std_logic;
   SIGNAL Freeze1       : std_logic;
   SIGNAL validSC0      : std_logic;
   SIGNAL SCinvld0      : std_logic;
   SIGNAL validSC1      : std_logic;
   SIGNAL SCinvld1      : std_logic;


   -- Component Declarations
   COMPONENT Arbitor
   PORT (
      CLK        : IN     std_logic ;
      nReset     : IN     std_logic ;
      ramQ       : IN     std_logic_vector (31 DOWNTO 0);
      ramState   : IN     std_logic_vector (1 DOWNTO 0);
      aiMemAddr1 : IN     std_logic_vector (31 DOWNTO 0);
      aiMemRead1 : IN     std_logic ;
      aiMemData1 : OUT    std_logic_vector (31 DOWNTO 0);
      iMemRead1  : OUT    std_logic ;
      ramRen     : OUT    std_logic ;
      ramWen     : OUT    std_logic ;
      aiMemRead0 : IN     std_logic ;
      aiMemAddr0 : IN     std_logic_vector (31 DOWNTO 0);
      aMemRead   : IN     std_logic ;
      aMemWrite  : IN     std_logic ;
      aMemAddr   : IN     std_logic_vector (31 DOWNTO 0);
      aMemRdData : OUT    std_logic_vector (31 DOWNTO 0);
      arbWait1   : OUT    std_logic ;
      arbWait0   : OUT    std_logic ;
      busy       : OUT    std_logic ;
      iMemRead0  : OUT    std_logic ;
      aiMemData0 : OUT    std_logic_vector (31 DOWNTO 0);
      aMemWrData : IN     std_logic_vector (31 DOWNTO 0);
      ramData    : OUT    std_logic_vector (31 DOWNTO 0);
      ramAddr    : OUT    std_logic_vector (15 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT IcacheTop
   PORT (
      aiMemData  : IN     std_logic_vector (31 DOWNTO 0);
      aiMemState : IN     std_logic_vector (1 DOWNTO 0);
      clk        : IN     std_logic;
      iMemAddr   : IN     std_logic_vector (31 DOWNTO 0);
      iMemRead   : IN     std_logic;
      nReset     : IN     std_logic;
      aiMemAddr  : OUT    std_logic_vector (31 DOWNTO 0);
      aiMemRead  : OUT    std_logic;
      iMemData   : OUT    std_logic_vector (31 DOWNTO 0);
      ihit       : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT coco
   PORT (
      CLK           : IN     std_logic;
      MEM_MEM2REG0  : IN     std_logic;
      MEM_MEM2REG1  : IN     std_logic;
      MEM_MemWr0    : IN     std_logic;
      MEM_MemWr1    : IN     std_logic;
      MEM_Out0      : IN     std_logic_vector (31 DOWNTO 0);
      MEM_Out1      : IN     std_logic_vector (31 DOWNTO 0);
      MEM_SC0       : IN     std_logic;
      MEM_SC1       : IN     std_logic;
      MemWait0      : IN     std_logic;
      MemWait1      : IN     std_logic;
      aMemAddr0     : IN     std_logic_vector (31 DOWNTO 0);
      aMemAddr1     : IN     std_logic_vector (31 DOWNTO 0);
      aMemRdData    : IN     std_logic_vector (31 DOWNTO 0);
      aMemRead0     : IN     std_logic;
      aMemRead1     : IN     std_logic;
      aMemWrData0   : IN     std_logic_vector (31 DOWNTO 0);
      aMemWrData1   : IN     std_logic_vector (31 DOWNTO 0);
      aMemWrite0    : IN     std_logic;
      aMemWrite1    : IN     std_logic;
      busy          : IN     std_logic;
      cacheSnoopEn0 : IN     std_logic;
      cacheSnoopEn1 : IN     std_logic;
      chrSnpWait0   : IN     std_logic;
      chrSnpWait1   : IN     std_logic;
      finalHalt0    : IN     std_logic;
      finalHalt1    : IN     std_logic;
      nReset        : IN     std_logic;
      ramState      : IN     std_logic_vector (1 DOWNTO 0);
      validSC0      : IN     std_logic;
      validSC1      : IN     std_logic;
      HALT          : OUT    std_logic;
      SCinvld0      : OUT    std_logic;
      SCinvld1      : OUT    std_logic;
      aMemAddr      : OUT    std_logic_vector (31 DOWNTO 0);
      aMemRdData0   : OUT    std_logic_vector (31 DOWNTO 0);
      aMemRdData1   : OUT    std_logic_vector (31 DOWNTO 0);
      aMemRead      : OUT    std_logic;
      aMemWrData    : OUT    std_logic_vector (31 DOWNTO 0);
      aMemWrite     : OUT    std_logic;
      cMemAddr0     : OUT    std_logic_vector (31 DOWNTO 0);
      cMemAddr1     : OUT    std_logic_vector (31 DOWNTO 0);
      cMemSnoopEn0  : OUT    std_logic;
      cMemSnoopEn1  : OUT    std_logic;
      cMemWait0     : OUT    std_logic;
      cMemWait1     : OUT    std_logic;
      cRdX0         : OUT    std_logic;
      cRdX1         : OUT    std_logic;
      cWait0        : OUT    std_logic;
      cWait1        : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT dcache
   PORT (
      CLK          : IN     std_logic ;
      nReset       : IN     std_logic ;
      Halt         : IN     std_logic ;                     -- CPU side
      MemRead      : IN     std_logic ;                     -- CPU side
      MemWrite     : IN     std_logic ;                     -- CPU side
      MemWait      : OUT    std_logic ;                     -- CPU side
      MemAddr      : IN     std_logic_vector (31 DOWNTO 0); -- CPU side
      MemRdData    : OUT    std_logic_vector (31 DOWNTO 0); -- CPU side
      MemWrData    : IN     std_logic_vector (31 DOWNTO 0); -- CPU side
      aMemWait     : IN     std_logic ;                     -- arbitrator side
      aMemState    : IN     std_logic_vector (1 DOWNTO 0);  -- arbitrator side
      aMemRead     : OUT    std_logic ;                     -- arbitrator side
      aMemWrite    : OUT    std_logic ;                     -- arbitrator side
      aMemAddr     : OUT    std_logic_vector (31 DOWNTO 0); -- arbitrator side
      aMemRdData   : IN     std_logic_vector (31 DOWNTO 0); -- arbitrator side
      aMemWrData   : OUT    std_logic_vector (31 DOWNTO 0); -- arbitrator side
      --LL and SC
      LL           : IN     std_logic ;
      --LL and SC
      SC           : IN     std_logic ;
      -- Coherance signals
      cMemSnoopEn  : IN     std_logic ;
      cMemAddr     : IN     std_logic_vector (31 DOWNTO 0);
      finalHalt    : OUT    STD_LOGIC ;
      WB_Rw        : IN     std_logic_vector (4 DOWNTO 0);
      cRdX         : IN     std_logic ;
      chrWaitDbusy : OUT    std_logic ;
      cacheSnoopEn : OUT    std_logic ;
      invld        : IN     std_logic ;
      validSC      : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT localCPU
   PORT (
      CLK         : IN     std_logic ;
      nReset      : IN     std_logic ;
      ramState    : IN     std_logic_vector (1 DOWNTO 0);
      MEM_MEM2REG : OUT    std_logic ;
      IF_Instr    : IN     std_logic_vector (31 DOWNTO 0);
      PC          : OUT    std_logic_vector (31 DOWNTO 0);
      MEM_MemWr   : OUT    std_logic ;
      MEM_Out     : OUT    std_logic_vector (31 DOWNTO 0);
      hit         : IN     std_logic ;
      WB_Halt     : OUT    std_logic ;
      cpuwait     : IN     std_logic ;
      MEM_ramOut  : IN     std_logic_vector (31 DOWNTO 0);
      MEM_BusB    : OUT    std_logic_vector (31 DOWNTO 0);
      Freeze      : OUT    std_logic ;
      MEM_Rw      : OUT    std_logic_vector (4 DOWNTO 0);
      MEM_LL      : OUT    std_logic ;
      MEM_SC      : OUT    std_logic ;
      pid         : IN     std_logic 
   );
   END COMPONENT;

BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 cpuNdcacheStop0
   -- cpu0Stop 1                                        
   cpuwait0 <= (arbWait0 or cwait0);
   aMemWait0 <= '1' when cMemWait0 ='1' else -- normal control over dcache
               '1' when MemWait0 ='0' and freeze0 ='1' else -- need to keep dcache in update while pipe is paused
               '0' when (WB_halt0='1' and WB_halt1='0') and ((cMemSnoopEn0 = '1' or cRdx0='1') and chrSnpWait0 = '1') else -- dump all when other trying to get data
               '1' when (WB_halt0='1' and WB_halt1='0') else -- dcache halt dump needs to wait on other cache
               '0';
   pid0 <= '0';

   -- HDL Embedded Text Block 2 cpuNdcahceStop
   -- cpu1Stop 2                                        
   cpuwait1 <= (arbWait1 or cwait1);
   aMemWait1 <= '1' when cMemWait1 ='1' else -- normal control over dcache
               '1' when MemWait1 ='0' and freeze1 ='1' else -- need to keep dcache in update while pipe is paused
               '0' when (WB_halt1='1' and WB_halt0='0') and ((cMemSnoopEn1 = '1' or cRdx1='1') and chrSnpWait1 = '1') else -- dump all when other trying to get data            
               '1' when (WB_halt1 ='1' AND WB_halt0='0') else -- dcache halt dump needs to wait on other dcache halt
               '0';
   pid1 <= '1';
   


   -- Instance port mappings.
   MemArb : Arbitor
      PORT MAP (
         CLK        => CLK,
         nReset     => nReset,
         ramQ       => ramQ,
         ramState   => ramState,
         aiMemAddr1 => aiMemAddr1,
         aiMemRead1 => aiMemRead1,
         aiMemData1 => aiMemData1,
         iMemRead1  => iMemRead1,
         ramRen     => ramRen,
         ramWen     => ramWen,
         aiMemRead0 => aiMemRead0,
         aiMemAddr0 => aiMemAddr0,
         aMemRead   => aMemRead,
         aMemWrite  => aMemWrite,
         aMemAddr   => aMemAddr,
         aMemRdData => aMemRdData,
         arbWait1   => arbWait1,
         arbWait0   => arbWait0,
         busy       => busy,
         iMemRead0  => iMemRead0,
         aiMemData0 => aiMemData0,
         aMemWrData => aMemWrData,
         ramData    => ramData,
         ramAddr    => ramAddr
      );
   icache0 : IcacheTop
      PORT MAP (
         clk        => CLK,
         nReset     => nReset,
         iMemRead   => iMemRead0,
         ihit       => ihit0,
         iMemAddr   => PC0,
         iMemData   => iMemData0,
         aiMemState => ramState,
         aiMemData  => aiMemData0,
         aiMemRead  => aiMemRead0,
         aiMemAddr  => aiMemAddr0
      );
   icache1 : IcacheTop
      PORT MAP (
         clk        => CLK,
         nReset     => nReset,
         iMemRead   => iMemRead1,
         ihit       => ihit1,
         iMemAddr   => PC1,
         iMemData   => iMemData1,
         aiMemState => ramState,
         aiMemData  => aiMemData1,
         aiMemRead  => aiMemRead1,
         aiMemAddr  => aiMemAddr1
      );
   ChrCont : coco
      PORT MAP (
         CLK           => CLK,
         nReset        => nReset,
         ramState      => ramState,
         MemWait0      => MemWait0,
         MemWait1      => MemWait1,
         aMemAddr0     => aMemAddr0,
         aMemAddr1     => aMemAddr1,
         aMemRdData    => aMemRdData,
         aMemRead0     => aMemRead0,
         aMemRead1     => aMemRead1,
         aMemWrData0   => aMemWrData0,
         aMemWrData1   => aMemWrData1,
         aMemWrite0    => aMemWrite0,
         aMemWrite1    => aMemWrite1,
         busy          => busy,
         finalHalt0    => finalHalt0,
         finalHalt1    => finalHalt1,
         HALT          => HALT,
         aMemAddr      => aMemAddr,
         aMemRdData0   => aMemRdData0,
         aMemRdData1   => aMemRdData1,
         aMemRead      => aMemRead,
         aMemWrite     => aMemWrite,
         cMemAddr0     => cMemAddr0,
         cMemAddr1     => cMemAddr1,
         cMemSnoopEn0  => cMemSnoopEn0,
         cMemSnoopEn1  => cMemSnoopEn1,
         cMemWait0     => cMemWait0,
         cMemWait1     => cMemWait1,
         cWait0        => cWait0,
         cWait1        => cWait1,
         aMemWrData    => aMemWrData,
         MEM_MEM2REG1  => MEM_MEM2REG1,
         MEM_MemWr1    => MEM_MemWr1,
         MEM_Out1      => MEM_Out1,
         MEM_MEM2REG0  => MEM_MEM2REG0,
         MEM_MemWr0    => MEM_MemWr0,
         MEM_Out0      => MEM_Out0,
         cRdX0         => cRdX0,
         cRdX1         => cRdX1,
         chrSnpWait0   => chrSnpWait0,
         chrSnpWait1   => chrSnpWait1,
         cacheSnoopEn1 => cacheSnoopEn1,
         cacheSnoopEn0 => cacheSnoopEn0,
         validSC0      => validSC0,
         SCinvld0      => SCinvld0,
         validSC1      => validSC1,
         SCinvld1      => SCinvld1,
         MEM_SC0       => MEM_SC0,
         MEM_SC1       => MEM_SC1
      );
   dcache0 : dcache
      PORT MAP (
         CLK          => CLK,
         nReset       => nReset,
         Halt         => WB_Halt0,
         MemRead      => MEM_MEM2REG0,
         MemWrite     => MEM_MemWr0,
         MemWait      => MemWait0,
         MemAddr      => MEM_Out0,
         MemRdData    => MemRdData0,
         MemWrData    => MEM_BusB0,
         aMemWait     => aMemWait0,
         aMemState    => ramState,
         aMemRead     => aMemRead0,
         aMemWrite    => aMemWrite0,
         aMemAddr     => aMemAddr0,
         aMemRdData   => aMemRdData0,
         aMemWrData   => aMemWrData0,
         LL           => MEM_LL0,
         SC           => MEM_SC0,
         cMemSnoopEn  => cMemSnoopEn0,
         cMemAddr     => cMemAddr0,
         finalHalt    => finalHalt0,
         WB_Rw        => MEM_Rw0,
         cRdX         => cRdX0,
         chrWaitDbusy => chrSnpWait0,
         cacheSnoopEn => cacheSnoopEn0,
         invld        => SCinvld0,
         validSC      => validSC0
      );
   dchache1 : dcache
      PORT MAP (
         CLK          => CLK,
         nReset       => nReset,
         Halt         => WB_Halt1,
         MemRead      => MEM_MEM2REG1,
         MemWrite     => MEM_MemWr1,
         MemWait      => MemWait1,
         MemAddr      => MEM_Out1,
         MemRdData    => MemRdData1,
         MemWrData    => MEM_BusB1,
         aMemWait     => aMemWait1,
         aMemState    => ramState,
         aMemRead     => aMemRead1,
         aMemWrite    => aMemWrite1,
         aMemAddr     => aMemAddr1,
         aMemRdData   => aMemRdData1,
         aMemWrData   => aMemWrData1,
         LL           => MEM_LL1,
         SC           => MEM_SC1,
         cMemSnoopEn  => cMemSnoopEn1,
         cMemAddr     => cMemAddr1,
         finalHalt    => finalHalt1,
         WB_Rw        => MEM_Rw1,
         cRdX         => cRdX1,
         chrWaitDbusy => chrSnpWait1,
         cacheSnoopEn => cacheSnoopEn1,
         invld        => SCinvld1,
         validSC      => validSC1
      );
   cpu0 : localCPU
      PORT MAP (
         CLK         => CLK,
         nReset      => nReset,
         ramState    => ramState,
         MEM_MEM2REG => MEM_MEM2REG0,
         IF_Instr    => iMemData0,
         PC          => PC0,
         MEM_MemWr   => MEM_MemWr0,
         MEM_Out     => MEM_Out0,
         hit         => ihit0,
         WB_Halt     => WB_Halt0,
         cpuwait     => cpuwait0,
         MEM_ramOut  => MemRdData0,
         MEM_BusB    => MEM_BusB0,
         Freeze      => Freeze0,
         MEM_Rw      => MEM_Rw0,
         MEM_LL      => MEM_LL0,
         MEM_SC      => MEM_SC0,
         pid         => pid0
      );
   cpu1 : localCPU
      PORT MAP (
         CLK         => CLK,
         nReset      => nReset,
         ramState    => ramState,
         MEM_MEM2REG => MEM_MEM2REG1,
         IF_Instr    => iMemData1,
         PC          => PC1,
         MEM_MemWr   => MEM_MemWr1,
         MEM_Out     => MEM_Out1,
         hit         => ihit1,
         WB_Halt     => WB_Halt1,
         cpuwait     => cpuwait1,
         MEM_ramOut  => MemRdData1,
         MEM_BusB    => MEM_BusB1,
         Freeze      => Freeze1,
         MEM_Rw      => MEM_Rw1,
         MEM_LL      => MEM_LL1,
         MEM_SC      => MEM_SC1,
         pid         => pid1
      );

END struct;

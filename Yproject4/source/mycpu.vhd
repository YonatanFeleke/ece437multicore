-- VHDL Entity multiCore_lib.mycpu.symbol
--
-- Created:
--          by - mg255.bin (cparch03.ecn.purdue.edu)
--          at - 14:46:43 11/02/11
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.2a (Build 7)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY mycpu IS
   PORT( 
      CLK      : IN     std_logic;
      nReset   : IN     std_logic;
      ramState : IN     std_logic_vector (1 DOWNTO 0);
      ramAddr  : OUT    std_logic_vector (31 DOWNTO 0);
      ramRen   : OUT    std_logic;
      ramWen   : OUT    std_logic;
      ramData  : OUT    std_logic_vector (31 DOWNTO 0);
      ramQ     : IN     std_logic_vector (31 DOWNTO 0)
   );

-- Declarations

END mycpu ;

--
-- VHDL Architecture multiCore_lib.mycpu.struct
--
-- Created:
--          by - mg255.bin (cparch03.ecn.purdue.edu)
--          at - 14:46:43 11/02/11
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.2a (Build 7)
--
-- 
-- 
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY std;
USE std.textio.all;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.all;
USE ieee.std_logic_textio.all;

LIBRARY multiCore_lib;

ARCHITECTURE struct OF mycpu IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL MEM_MemWr    : std_logic;
   SIGNAL PC           : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_MemWr1   : std_logic;
   SIGNAL PC1          : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_MEM2REG  : std_logic;
   SIGNAL MEM_Out      : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_MEM2REG1 : std_logic;
   SIGNAL MEM_Out1     : std_logic_vector(31 DOWNTO 0);
   SIGNAL WB_Halt      : std_logic;
   SIGNAL MemRdData    : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_BusB     : std_logic_vector(31 DOWNTO 0);
   SIGNAL MEM_BusB1    : std_logic_vector(31 DOWNTO 0);
   SIGNAL WB_Halt1     : std_logic;
   SIGNAL iMemData     : std_logic_vector(31 DOWNTO 0);
   SIGNAL iMemData1    : std_logic_vector(31 DOWNTO 0);
   SIGNAL iMemWait     : std_logic;
   SIGNAL iMemWait1    : std_logic;
   SIGNAL MemWait      : std_logic;
   SIGNAL aMemRead     : std_logic;
   SIGNAL aMemWrite    : std_logic;
   SIGNAL aMemWrData   : std_logic_vector(31 DOWNTO 0);
   SIGNAL MemRdData1   : std_logic_vector(31 DOWNTO 0);
   SIGNAL ArbWait      : std_logic;
   SIGNAL ArbWait1     : std_logic;
   SIGNAL aMemRead1    : std_logic;
   SIGNAL aMemAddr     : std_logic_vector(31 DOWNTO 0);
   SIGNAL aMemWrite1   : std_logic;
   SIGNAL aMemWrData1  : std_logic_vector(31 DOWNTO 0);
   SIGNAL iMemRead     : std_logic;
   SIGNAL iMemRead1    : std_logic;
   SIGNAL aiMemState   : std_logic_vector(1 DOWNTO 0);
   SIGNAL aiMemData    : std_logic_vector(31 DOWNTO 0);
   SIGNAL aiMemData1   : std_logic_vector(31 DOWNTO 0);
   SIGNAL aMemWait     : std_logic;
   SIGNAL aMemRdData   : std_logic_vector(31 DOWNTO 0);
   SIGNAL aMemWait1    : std_logic;
   SIGNAL aMemRdData1  : std_logic_vector(31 DOWNTO 0);


   -- Component Declarations
   COMPONENT Arbitor
   PORT (
      CLK         : IN     std_logic ;
      nReset      : IN     std_logic ;
      ramQ        : IN     std_logic_vector (31 DOWNTO 0);
      ramState    : IN     std_logic_vector (1 DOWNTO 0);
      ArbWait     : OUT    std_logic ;
      ArbWait1    : OUT    std_logic ;
      aMemRdData  : OUT    std_logic_vector (31 DOWNTO 0);
      aMemRdData1 : OUT    std_logic_vector (31 DOWNTO 0);
      aMemWait    : OUT    std_logic ;
      aMemWait1   : OUT    std_logic ;
      aiMemData   : OUT    std_logic_vector (31 DOWNTO 0);
      aiMemData1  : OUT    std_logic_vector (31 DOWNTO 0);
      iMemRead    : OUT    std_logic ;
      iMemRead1   : OUT    std_logic ;
      ramAddr     : OUT    std_logic_vector (31 DOWNTO 0);
      ramData     : OUT    std_logic_vector (31 DOWNTO 0);
      ramRen      : OUT    std_logic ;
      ramWen      : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT IcacheTop
   PORT (
      aiMemData  : IN     std_logic_vector (31 DOWNTO 0);
      aiMemState : IN     std_logic_vector (1 DOWNTO 0);
      clk        : IN     std_logic;
      iMemAddr   : IN     std_logic_vector (31 DOWNTO 0);
      iMemRead   : IN     std_logic;
      nReset     : IN     std_logic;
      aiMemAddr  : OUT    std_logic_vector (31 DOWNTO 0);
      aiMemRead  : OUT    std_logic;
      iMemData   : OUT    std_logic_vector (31 DOWNTO 0);
      iMemWait   : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT coheranceCont
   PORT (
      CLK         : IN     std_logic ;
      MemWait     : IN     std_logic ;
      aMemAddr    : IN     std_logic_vector (31 DOWNTO 0);
      aMemRead    : IN     std_logic ;
      aMemRead1   : IN     std_logic ;
      aMemWrData  : IN     std_logic_vector (31 DOWNTO 0);
      aMemWrData1 : IN     std_logic_vector (31 DOWNTO 0);
      aMemWrite   : IN     std_logic ;
      aMemWrite1  : IN     std_logic ;
      nReset      : IN     std_logic ;
      ramState    : IN     std_logic_vector (1 DOWNTO 0)
   );
   END COMPONENT;
   COMPONENT dcache
   PORT (
      CLK        : IN     std_logic;
      Halt       : IN     std_logic;
      MemAddr    : IN     std_logic_vector (31 DOWNTO 0);
      MemRead    : IN     std_logic;
      MemWrData  : IN     std_logic_vector (31 DOWNTO 0);
      MemWrite   : IN     std_logic;
      aMemRdData : IN     std_logic_vector (31 DOWNTO 0);
      aMemState  : IN     std_logic_vector (1 DOWNTO 0);
      aMemWait   : IN     std_logic;
      nReset     : IN     std_logic;
      MemRdData  : OUT    std_logic_vector (31 DOWNTO 0);
      MemWait    : OUT    std_logic;
      aMemAddr   : OUT    std_logic_vector (31 DOWNTO 0);
      aMemRead   : OUT    std_logic;
      aMemWrData : OUT    std_logic_vector (31 DOWNTO 0);
      aMemWrite  : OUT    std_logic;
      finalHalt  : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT localCPU
   PORT (
      CLK         : IN     std_logic ;
      nReset      : IN     std_logic ;
      ramState    : IN     std_logic_vector (1 DOWNTO 0);
      MEM_MEM2REG : OUT    std_logic ;
      IF_Instr    : IN     std_logic_vector (31 DOWNTO 0);
      PC          : OUT    std_logic_vector (31 DOWNTO 0);
      MEM_MemWr   : OUT    std_logic ;
      MEM_Out     : OUT    std_logic_vector (31 DOWNTO 0);
      hit         : IN     std_logic ;
      WB_Halt     : OUT    std_logic ;
      ArbWait     : IN     std_logic ;
      MEM_ramOut  : IN     std_logic_vector (31 DOWNTO 0);
      MEM_BusB    : OUT    std_logic_vector (31 DOWNTO 0)
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : Arbitor USE ENTITY multiCore_lib.Arbitor;
   FOR ALL : IcacheTop USE ENTITY multiCore_lib.IcacheTop;
   FOR ALL : coheranceCont USE ENTITY multiCore_lib.coheranceCont;
   FOR ALL : dcache USE ENTITY multiCore_lib.dcache;
   FOR ALL : localCPU USE ENTITY multiCore_lib.localCPU;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   U_6 : Arbitor
      PORT MAP (
         CLK         => CLK,
         nReset      => nReset,
         ramQ        => ramQ,
         ramState    => ramState,
         ArbWait     => ArbWait,
         ArbWait1    => ArbWait1,
         aMemRdData  => aMemRdData,
         aMemRdData1 => aMemRdData1,
         aMemWait    => aMemWait,
         aMemWait1   => aMemWait1,
         aiMemData   => aiMemData,
         aiMemData1  => aiMemData1,
         iMemRead    => iMemRead,
         iMemRead1   => iMemRead1,
         ramAddr     => ramAddr,
         ramData     => ramData,
         ramRen      => ramRen,
         ramWen      => ramWen
      );
   icache1 : IcacheTop
      PORT MAP (
         clk        => CLK,
         nReset     => nReset,
         iMemRead   => iMemRead,
         iMemWait   => iMemWait,
         iMemAddr   => PC,
         iMemData   => iMemData1,
         aiMemState => ramState,
         aiMemData  => aiMemData,
         aiMemRead  => OPEN,
         aiMemAddr  => OPEN
      );
   icache2 : IcacheTop
      PORT MAP (
         clk        => CLK,
         nReset     => nReset,
         iMemRead   => iMemRead1,
         iMemWait   => iMemWait1,
         iMemAddr   => PC1,
         iMemData   => iMemData,
         aiMemState => aiMemState,
         aiMemData  => aiMemData1,
         aiMemRead  => OPEN,
         aiMemAddr  => OPEN
      );
   ChrCont : coheranceCont
      PORT MAP (
         CLK         => CLK,
         MemWait     => MemWait,
         aMemAddr    => aMemAddr,
         aMemRead    => aMemRead,
         aMemRead1   => aMemRead1,
         aMemWrData  => aMemWrData,
         aMemWrData1 => aMemWrData1,
         aMemWrite   => aMemWrite,
         aMemWrite1  => aMemWrite1,
         nReset      => nReset,
         ramState    => ramState
      );
   dcache1 : dcache
      PORT MAP (
         CLK        => CLK,
         nReset     => nReset,
         Halt       => WB_Halt,
         MemRead    => MEM_MEM2REG1,
         MemWrite   => MEM_MemWr,
         MemWait    => MemWait,
         MemAddr    => MEM_Out1,
         MemRdData  => MemRdData1,
         MemWrData  => MEM_BusB,
         finalHalt  => OPEN,
         aMemWait   => aMemWait,
         aMemState  => ramState,
         aMemRead   => aMemRead,
         aMemWrite  => aMemWrite,
         aMemAddr   => OPEN,
         aMemRdData => aMemRdData,
         aMemWrData => aMemWrData
      );
   dchache2 : dcache
      PORT MAP (
         CLK        => CLK,
         nReset     => nReset,
         Halt       => WB_Halt1,
         MemRead    => MEM_MEM2REG,
         MemWrite   => MEM_MemWr1,
         MemWait    => OPEN,
         MemAddr    => MEM_Out,
         MemRdData  => MemRdData,
         MemWrData  => MEM_BusB1,
         finalHalt  => OPEN,
         aMemWait   => aMemWait1,
         aMemState  => ramState,
         aMemRead   => aMemRead1,
         aMemWrite  => aMemWrite1,
         aMemAddr   => aMemAddr,
         aMemRdData => aMemRdData1,
         aMemWrData => aMemWrData1
      );
   U_0 : localCPU
      PORT MAP (
         CLK         => CLK,
         nReset      => nReset,
         ramState    => ramState,
         MEM_MEM2REG => MEM_MEM2REG,
         IF_Instr    => iMemData,
         PC          => PC1,
         MEM_MemWr   => MEM_MemWr1,
         MEM_Out     => MEM_Out,
         hit         => iMemWait1,
         WB_Halt     => WB_Halt1,
         ArbWait     => ArbWait1,
         MEM_ramOut  => MemRdData,
         MEM_BusB    => MEM_BusB1
      );
   cpu1 : localCPU
      PORT MAP (
         CLK         => CLK,
         nReset      => nReset,
         ramState    => ramState,
         MEM_MEM2REG => MEM_MEM2REG1,
         IF_Instr    => iMemData1,
         PC          => PC,
         MEM_MemWr   => MEM_MemWr,
         MEM_Out     => MEM_Out1,
         hit         => iMemWait,
         WB_Halt     => WB_Halt,
         ArbWait     => ArbWait,
         MEM_ramOut  => MemRdData1,
         MEM_BusB    => MEM_BusB
      );

END struct;

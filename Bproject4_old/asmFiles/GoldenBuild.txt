policies about golden build module usage:

1) golden build including a correct completed pipeline + one correct i-cache + one correct d-cache is for multi-core lab use only. 
   however, we still strongly encourage you to use your own design of pipeline and caches to proceed on dual-core.

2) golden module is for people who think they will be having hard time to pass dual-core outcome with their highly broken pipeline and cache, 
   which usually is not the case for most of you since you need to accomplish basic pipeline and caches to pass their previous outcomes.

3) you have option to completely use your own design, or all of the provided golden modules, or part of the provided golden modules, 
   however, using code written by other people outside of your team and libraries provided from external sources are subject to plagerism.

4) we simply cannot provide you the source code of the golden modules at any point, however, they have been tested with their correct functionanlities, 
   but it is still up to you to understand their behavior and figure out ways to use them in your own design.

5) grading on using golden modules will be all points possible from general design requirement, source simulation, and synthesis simulation only,
   we cannot grade golden module with hardware due to lack of support to external custom library by quartus software(quartus requires source code), 
   And if you completely use all provided golden modules(including pipeline and two caches), no grading script points will be given 
   since it is fair that people who choose to continue using and fixing their own design besically gets more points than people use golden modules.         

6) if you choose to use part of the golden module, in addition with what you can accomplish, you will recieve the following percentage of grading script
   points if you choose use your own design instead using the corresponding golden module:
	1) pipeline 50%
	2) D-cache  30%
	3) I-cache  20%    
   for example, if you completely use your own design, you will get all points possible from both demo(source, mapped, hardware) and grading script;
   if you completely use all three golden modules, you will get all points possible from demo(source and mapped), no hardware, no grading script points;
   if you choose to use your own pipeline plus using golden module of only two caches, you will get all points possible from demo(source and mapped) 
   plus 50% of grading script points if your design is working in demo. if you are only using golden module of D-cache, then plus you get 50%+20%=70%
   from grading script, if you are using only pipeline golden module and your own two caches, then plus you get 20%+30% of your grading script points.


to use the golden build module:

note:
(1) and (2) are for source simulation:
(3) and (4) are for synthesis simulation:

1) include this line in your modelsim.ini:

golden = $HOME437/lib/golden

after line: lpm = ./work

note: do not do this if you are not using golden build.

2) include these two lines in your own design top levels:

library golden;
use golden.all;

note: for using part of the golden modules, replace "all" with the name of a particular module. 

3) pre-synthesised files for golden modules: 

you can download them from 
http://cobweb.ecn.purdue.edu/~ece437l/labs/lab10/files/golden_mapped/

4) neccessary implementation for synthesis:

you want to put all your logic in your sub-modules, your top level will only connecting all the modules, 
so you can synthesis your own designed sub-modules separately from the given post-synthesised golden modules,
and then compile all the post-synthesis modules in modelsim with the source code of top level module to 
preform your mapped simulation, you do not want to synthesis your top level module because quartus will not do
synthesis to file that does not have all source code available of all its dependant component modules.
Therefore, since your sub-modules are all synthesised separately and the source code of golden module is not given
you cannot synthesis your top level as before, we will just leave it as source to compile in modelsim.
And for that reason, you dont want to put any logic in your top level, since we want your design get synthesised 
as much as possible.    



golden build modules guideline:

pipeline is given as "mycpu", plus i-cache and d-cache are given, namely "i" and "d",
while the top level, ram, vram, and their possible wrappers are not given. 
you need to hook everything together with your own top level as well as implementing new coherence controller. 
note that the external signals in d-cache can be used for snooping and coherence controller.
it would possibly be helpful if you want to build your testbench to study the behavior of each of the modules.

the entity of the provided golden modules are: 

-----------------------------------------------------------------------------------------------------------------------

entity mycpu is
  port 
  (
    CLK:	 		in std_logic;
    nReset: 			in std_logic;
    first_addr: 		in std_logic_vector(31 downto 0);	--where your pc starts, like x"000" or x"200"
    rami_data:  		in std_logic_vector(31 downto 0);	--data output from i-cache to the pipeline 
    ramd_data:  		in std_logic_vector(31 downto 0);	--data output from d-cache to the pipeline  
    i_kill:     		in std_logic;				--i_kill when miss and memory is busy
    d_kill:     		in std_logic;				--d_kill is similar when you want CPU to wait
    if_ramaddr_out: 		out std_logic_vector(31 downto 0);	--if-stage output address to access i-cache 
    mem_ramread_out: 		out std_logic;				--if mem read
    mem_ramwrite_out: 		out std_logic;				--if mem write
    mem_ramdata_out: 		out std_logic_vector(31 downto 0);	--data input from pipeline to d-cache
    mem_ramaddr_out: 		out std_logic_vector(31 downto 0);	--address input from pipeline to d-cache
    halt_out: 			out std_logic;				--halt
    link_out: 			out std_logic				--when ll/sc is issued
  );
end mycpu;

entity i is
  port
  (
    clk:                        in  std_logic;
    nreset:                     in  std_logic;
    if_addr, ram_data:          in  std_logic_vector(31 downto 0);	--if-stage address, data input from ram
    mem_busy:                   in  std_logic;				--if mem is busy
    i_data:                     out std_logic_vector(31 downto 0);	--data output of i-cache 
    i_kill:                     out std_logic;				--if i is busy
    i_request:                  out std_logic				--when i-cache encouters miss, requesting data
  );
end i;

entity d is 
  port
  ( 
    clk:                        in  std_logic;
    nreset:                     in  std_logic;
    halt:                       in  std_logic;				--halt from pipeline
    link:                       in  std_logic;				--link from pipeline
    ram_data:                   in  std_logic_vector(31 downto 0);	--data input from ram
    ram_busy:                   in  std_logic;				--if ram is busy
    mem_ramaddr, mem_ramdata:   in  std_logic_vector(31 downto 0);	--address and data from pipeline 
    mem_ramread, mem_ramwrite:  in  std_logic;				--read/write control from pipeline
    ext_read, ext_write:        in  std_logic;				--external read / write control
    ext_address:                in  std_logic_vector(15 downto 0);	--external address
    ext_link:                   in  std_logic;				--external link
    d_data:                     out std_logic_vector(31 downto 0);	--data output of d-cache
    d_read, d_write, d_kill:    out std_logic;				--d-cache flags
    d_address:                  out std_logic_vector(15 downto 0);	--address need to be accessed from mem
    d_writedata:                out std_logic_vector(31 downto 0);	--data to be written to mem
    d_extvalid:                 out std_logic;				--external valid flag
    d_extwrite:                 out std_logic;				--external write flag
    d_halt:                     out std_logic;				--d-cache halt flag
    d_link:                     out std_logic				--d-cache link flag
  );
end d;

------------------------------------------------------------------------------------------------------------------

here is the example that you don not have to follow: 

for example you can build an additional ram_select module like the following:

------------------------------------------------------------------------------------------------------------------

entity ram_select is
  port
  (
    clk:                                        in std_logic;
    nreset:                                     in std_logic;
    p1_halt, p1_link:                           in std_logic;
    p1_if_addr, p1_mem_ramaddr, p1_mem_ramdata: in std_logic_vector(31 downto 0);
    p1_mem_ramread, p1_mem_ramwrite:            in std_logic;
    p2_halt, p2_link:                           in std_logic;
    p2_if_addr, p2_mem_ramaddr, p2_mem_ramdata: in std_logic_vector(31 downto 0);
    p2_mem_ramread, p2_mem_ramwrite:            in std_logic;
    dumpAddr:                                   in std_logic_vector(15 downto 0);
    p1_i_data:                                  out std_logic_vector(31 downto 0);
    p1_i_kill:                                  out std_logic;
    p1_d_data:                                  out std_logic_vector(31 downto 0);
    p1_d_kill:                                  out std_logic;
    p2_i_data:                                  out std_logic_vector(31 downto 0);
    p2_i_kill:                                  out std_logic;
    p2_d_data:                                  out std_logic_vector(31 downto 0);
    p2_d_kill:                                  out std_logic;
    r_data:                                     out std_logic_vector(31 downto 0);
    halt:                                       out std_logic
  );
end ram_select;

-----------------------------------------------------------------------------------------------------------------

which can manage two i-caches and two d-caches within like below:

-----------------------------------------------------------------------------------------------------------------

  U0_I: i port map(clk, nreset, p1_if_addr, ram_data, p1_i_busy,
                   p1_i_data, p1_i_kill, p1_i_request);
  U1_I: i port map(clk, nreset, p2_if_addr, ram_data, p2_i_busy,
                   p2_i_data, p2_i_kill, p2_i_request);

  U0_D: d port map(clk, nreset, p1_halt, p1_link, p1_ram_data, p1_d_busy, p1_mem_ramaddr,
                   p1_mem_ramdata, p1_mem_ramread, p1_mem_ramwrite,
                   p1_extread, p1_extwrite, p2_d_address, p2_d_link, p1_d_data_temp, p1_d_read, p1_d_write,
                   p1_d_kill, p1_d_address, p1_d_writedata,
                   p1_d_extvalid, p1_d_extwrite, p1_d_halt, p1_d_link);
  U1_D: d port map(clk, nreset, p2_halt, p2_link, p2_ram_data, p2_d_busy, p2_mem_ramaddr,
                   p2_mem_ramdata, p2_mem_ramread, p2_mem_ramwrite,
                   p2_extread, p2_extwrite, p1_d_address, p1_d_link, p2_d_data_temp, p2_d_read, p2_d_write,
                   p2_d_kill, p2_d_address, p2_d_writedata,
                   p2_d_extvalid, p2_d_extwrite, p2_d_halt, p2_d_link);

---------------------------------------------------------------------------------------------------------------

of course, in additional you need to connect with ram and vram. it would be better to start with latency = 0 or even just ram alone.

then your top level hierarchy will be like two mycpus connecting with ram_select:

------------------------------------------------------------------------------------------------------

  U0: mycpu port map(clk, nreset, x"00000000", p1_rami_data, p1_ramd_data, p1_i_kill, p1_d_kill,
                     p1_if_addr, p1_mem_ramread, p1_mem_ramwrite, p1_mem_ramdata,
                     p1_mem_ramaddr, p1_halt, p1_link);

  U1: mycpu port map(clk, nreset, x"00000200", p2_rami_data, p2_ramd_data, p2_i_kill, p2_d_kill,
                     p2_if_addr, p2_mem_ramread, p2_mem_ramwrite, p2_mem_ramdata,
                     p2_mem_ramaddr, p2_halt, p2_link);

  U2: ram_select port map(clk, nreset, p1_halt, p1_link, p1_if_addr, p1_mem_ramaddr, p1_mem_ramdata,
                          p1_mem_ramread, p1_mem_ramwrite, p2_halt, p2_link, p2_if_addr,
                          p2_mem_ramaddr, p2_mem_ramdata, p2_mem_ramread, p2_mem_ramwrite,
                          dumpAddr, p1_rami_data, p1_i_kill, p1_ramd_data, p1_d_kill,
                          p2_rami_data, p2_i_kill, p2_ramd_data, p2_d_kill, ram_data, halt);

------------------------------------------------------------------------------------------------------

and then ram_select manages all caches and rams and taking care of inter-core business including snooping, coherence controller, and arbitrator, etc.
of course, you can create sub-modules under ram_select, or decide to put everything in one, you can name the module as you like as well. 

Good luck! and Please feel free to ask the TA if you have any questions.
